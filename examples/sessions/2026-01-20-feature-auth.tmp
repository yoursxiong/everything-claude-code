# 会话：身份验证功能实现
**日期：** 2026-01-20
**开始时间：** 14:30
**最后更新：** 17:45

---

## 当前状态

正在进行 API 的 JWT 身份验证流开发。主要目标是用无状态令牌替换基于会话（session-based）的验证。

### 已完成
- [x] 使用 RS256 设置 JWT 签名
- [x] 创建了 `/auth/login` 终端
- [x] 添加了刷新令牌（refresh token）轮换
- [x] 修复了令牌过期 Bug（之前使用的是秒，应使用毫秒）

### 进行中
- [ ] 为身份验证终端添加频率限制（rate limiting）
- [ ] 实现登出的令牌黑名单

### 遇到的阻碍
1. **jsonwebtoken 版本不匹配** - v9.x 更改了 `verify()` 的签名，必须更新错误处理
2. **刷新令牌的 Redis TTL** - 以秒为单位设置 TTL 但传递的是毫秒

### 关键决策
- 使用 RS256 而非 HS256，以便在分布式服务中获得更好的安全性
- 将刷新令牌存储在 Redis 中，TTL 为 7 天
- 访问令牌（Access tokens）在 15 分钟后过期

### 修改的代码位置
- `src/middleware/auth.js` - JWT 验证中间件
- `src/routes/auth.js` - 登录/登出/刷新终端
- `src/services/token.service.js` - 令牌生成与校验

### 下次会话笔记
- 需要为基于 cookie 的令牌存储添加 CSRF 保护
- 考虑为刷新令牌绑定添加指纹识别（fingerprinting）
- 与团队讨论频率限制数值

### 需要加载的上下文
```
src/middleware/
src/routes/auth.js
src/services/token.service.js
```

---

## 会话日志

**14:30** - 开始会话，目标是 JWT 实现

**14:45** - 设置基础 JWT 签名。使用存储在环境变量中的密钥对执行 RS256。

**15:20** - 登录终端正常工作。发现 jsonwebtoken v9 的破坏性变更 - `verify()` 现在抛出不同的错误类型。更新了 catch 块：
```javascript
// 旧做法 (v8)
if (err.name === 'TokenExpiredError') { ... }

// 新做法 (v9)
if (err instanceof jwt.TokenExpiredError) { ... }
```

**16:00** - 刷新令牌轮换可以工作，但令牌立即过期。Bug：将 `Date.now()`（毫秒）传递给了期望秒数的 `expiresIn`。已修复：
```javascript
// 错误做法
expiresIn: Date.now() + 900000

// 正确做法
expiresIn: '15m'
```

**17:30** - 身份验证流完成。登录 -> 访问令牌 -> 刷新令牌 -> 新令牌。准备好明天进行频率限制工作。

**17:45** - 保存会话状态。
